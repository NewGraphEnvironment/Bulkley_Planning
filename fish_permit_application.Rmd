---
title: 
output:
  bookdown::word_document2:
    reference_docx: C:/Users/allan/OneDrive/New_Graph/Current/Code/R/Templates/RMDTemplates/R/word_template.docx
    bibliography: references.bib
    toc: no
    fig_caption: yes
  bookdown::html_document2:
    number_sections: no
    self_contained: yes
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=T, comment=NA, echo =FALSE, message=FALSE, warning=FALSE}
library("RPostgreSQL")
library(sf)
library(tidyverse)
library(xlsx)
library(flextable)

#Enter the values for you database connection
{
  dsn_database = "postgis"            
  dsn_hostname = "localhost"
  dsn_port = "5432"               
  dsn_uid = "postgres"        
  dsn_pwd = "postgres"
  
  
  #connect 
    drv <- dbDriver("PostgreSQL")
    conn <- dbConnect(drv, 
                      dbname = dsn_database,
                      host = dsn_hostname, 
                      port = dsn_port,
                      user = dsn_uid, 
                      password = dsn_pwd)

}

knitr::opts_chunk$set(echo=FALSE, comment=NA, message=FALSE, warning=FALSE, fig.align="center", fig.width = 5.118, fig.height = 3.409)
options(knitr.table.format = "html")


```

Rationale for sampling is to inform fish presence/absence and species composition as part of habitat confirmations to prioritize fish passage restoration at barrier culverts as per the Fish Passage Technical Working Group Phase 2 protocol
(https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage).  Presence/absence of fish, species composition and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration.  It is extremely unlikely that sampling will be conducted at more than 10 of the streams listed in the sampling location tables however until the sites are visited in the field it is difficult to determine if the sampling will be beneficial to inform the prioritization.  Please don't hesitate to contact me if you have any questions or concerns. Please note that the sampling will be completed before September 30, 2020 however the period is listed as Dec 31, 2019 on the applicati on to allow time outside of the busy field season for the data to be processed, QA'd and organized so that required reporti ng can be as informative as possible and submitted to the Province as per the permit conditions before 90 days has expired. 

```{r}
##read in the pscis layer with the asociated MoE region

##because this query takes a while it is probably easier to burn to file then pull from file to make the table in the future. In
##fact we should probably do that all the time for reproducability.

##make the query to pull out pscis info
query <- "SELECT p.stream_crossing_id, p.utm_zone, p.utm_easting, p.utm_northing, p.image_view_url, moe.region_name, ST_Transform(p.geom, 4326) as geom  
FROM whse_fish.pscis_assessment_svw p
INNER JOIN whse_admin_boundaries.eadm_wlap_region_bnd_area_svw moe
ON ST_Intersects(p.geom, moe.geom)"


pscis <- st_read(conn, query = query) 
  # select(-id)

# #grab things I need from pscis - lets add the MoE region to these as we pull them out
# pscis <- dbGetQuery(conn, "SELECT stream_crossing_id, utm_zone,utm_easting, utm_northing, image_view_url  
#                     FROM whse_fish.pscis_assessment_svw")


##read in the priority for follow up info
pscis_working <- dbGetQuery(conn, 
                            "SELECT *
                     FROM working.my_pscis_20190709")

permit_table <- pscis_working %>% 
  filter(watershed_group_code == 'BULK' &
           (my_priority == 'high' | my_priority == 'mod')) %>% 
  select(stream_crossing_id, my_stream_name, stream_name, wscode, upstr_species, my_priority, my_text) 


permit_table <- left_join(permit_table, pscis, by = "stream_crossing_id") %>% 
  select(region_name, my_stream_name, stream_name, wscode, stream_crossing_id,
         utm_zone,utm_easting, utm_northing, image_view_url,upstr_species, my_priority, my_text) %>% 
  mutate('wscode' = gsub("\\.","-", wscode),
         my_stream_name = case_when( is.na(my_stream_name) ~ stream_name,
                   TRUE ~ my_stream_name)) %>% 
  rename(MoE_Region = region_name, 'Watershed Code (1:20,000)' = wscode, Waterbody = my_stream_name, 
         PSCIS_stream_crossing_id = stream_crossing_id, Priority = my_priority, Comments = my_text) %>% 
  select(-stream_name)

table <- flextable::flextable(permit_table) %>%
  # flextable::my_theme_booktabs(fontsize = 12, left_just_cols = 2) %>%
  flextable::autofit() %>%
  flextable::set_caption('Potential sampling site stream details.')
table



 
# write.table(permit_table, "C:/Users/allan/OneDrive/New_Graph/Current/2019-023_Bulkley_fish_passage/permit/permit_streams.txt", 
#             sep = ",", quote = FALSE, row.names = F)
  

# setwd("C:/Users/allan/OneDrive/New_Graph/Current/2019-010_FWCP_Parsnip/permit")
# write.xlsx(permit_table, file="permit_details.xlsx", sheetName="sample_streams", append=FALSE, row.names=FALSE)
# ##this one needs to come from the "01_modelled_Part3.... file
# write.xlsx(as.data.frame(fish_watershed), file="permit_details.xlsx", sheetName="potential_species", append=TRUE, row.names=FALSE)
```




```{r table_fish}
##find the gnis id
# watersheds <- dbGetQuery(conn,
#                          "SELECT y.* 
#                          FROM whse_basemapping.fwa_named_watersheds_poly y
#                          WHERE (y.gnis_name LIKE 'Parsnip River') ")


fish_species_watershed <- sf::st_read(conn,
                                      query = "SELECT nws.gnis_name,nws.fwa_watershed_code, nws.gnis_id, x.species_code,x.species_name,x.observation_date
                   FROM whse_fish.fiss_fish_obsrvtn_pnt_sp x
                   INNER JOIN 
                   whse_basemapping.fwa_named_watersheds_poly nws
                   ON ST_intersects(x.geom, nws.geom) 
                   WHERE gnis_name LIKE 'Bulkley River'
                           GROUP BY x.species_code,x.species_name,nws.gnis_name,nws.gnis_id,x.observation_date,nws.fwa_watershed_code 
                           ORDER BY nws.gnis_name,nws.fwa_watershed_code,x.species_code")

fish_species_lookup <- dbGetQuery(conn,
                                  "Select * from whse_fish.species_codes_lookup")

# fish_species_lookup <- drake::readd(fish_data_submission) %>% 
#                    purrr::pluck('species_by_group') %>% 
#                    select(common_name, species_code, scientific_name)


fish_species_watershed <- merge (fish_species_watershed,
                                fish_species_lookup[,c("SPECIES_CODE","SCIENTIFIC_NAME")],
                                by.x = c("species_code"), by.y = c("SPECIES_CODE"),
                                all.x = TRUE)

# fish_species_watershed <- left_join(fish_species_watershed,
#                                     fish_species_lookup,
#                                     by = "species_code") 


##we need to remove Family: from the SCIENTIFIC_NAME column to facilitate a nice sort/lookup
##we could look at adding it after in brackets maybe
# fish_species_watershed$scientific_name <- gsub("Family: ", "", fish_species_watershed$scientific_name)

##select rows that have no scientific name 
no_scientific <- fish_species_watershed[is.na(fish_species_watershed$scientific_name),]



#use pipes to group 
fish_table <- fish_species_watershed %>%
  purrr::set_names(nm = tolower(names(.))) %>% 
  dplyr::group_by(scientific_name, species_name,gnis_name,species_code) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::arrange(gnis_name) %>% ##ditch the rare occurance which look like errors
  dplyr::filter(count > 1 & 
           # species_name != 'Dolly Varden' &
           species_name != 'Rainbow Smelt' &
           species_code != 'BT/DV' &
             species_code != 'AF' &
             species_code != 'OS' &
             species_code != 'SP' &
             species_code != 'TR' &
             species_code != 'LT' & ##just removing lake trout for this one
             !stringr::str_detect(species_name, "General")) %>%
  ungroup() %>% 
  select('Scientific Name' = scientific_name, 'Species Name' = species_name,
         'Species Code' = species_code) %>% 
  mutate_all(~replace_na(.,"-")) %>% 
  mutate_all(~stringr::str_replace_all(.,"NA", "-"))
  


table <- flextable::flextable(fish_table) %>%
  # flextable::my_theme_booktabs(fontsize = 12, left_just_cols = 2) %>%
  flextable::autofit() %>%
  flextable::set_caption('Fish species potentially encountered in Bulkley River watershed according to fisheries inventory summary records.')
table

```

